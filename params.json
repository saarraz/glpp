{"name":"Glpp","tagline":"OpenGL C++ Wrapper","body":"GL++ (glpp)\r\n===========\r\n\r\nOpenGL C++ Wrapper provides a C++ interface for the OpenGL API. The wrapper tries to expose all the logical objects of OpenGL standard to C++ native objects. This is not a graphics library, thus you will not find any assets manipulation or math functionality. However the library is designed to be easily coupled with an external math library like [glm](http://glm.g-truc.net/) or an assets manipulation library like [assimp](http://assimp.sourceforge.net/).\r\n\r\nThe major keypoints of GL++ API are:\r\n* Do not introduce new semantics.\r\n* Do not hide steps, by creating all-in-one functions.\r\n* Try to use common names with OpenGL C API to avoid confusion.\r\n* Use C++ language to represent OOP semantics (e.g. [OpenGL objects](http://www.opengl.org/wiki/OpenGL_Object) )\r\n\r\n\r\nComparison of using OpenGL C API and GL++\r\n-----------------------------------------\r\n\r\n### Creating a program and loading some shader files\r\n\r\nOpenGL C API\r\n```C\r\n// Prototype of a user function to load shader from file\r\nint loadshader(char * filename, GLchar** ShaderSource, unsigned long* len);\r\n\r\nGLuint vertexShader, fragmentShader, ProgramObject;\r\nGLchar* shaderSource;\r\nint shaderSourceLen;\r\n    \r\nvertexShaderObject = glCreateShader(GL_VERTEX_SHADER);\r\nloadshader(\"shaderfile.vert\", &shaderSource, &shaderSourceLen)\r\nglShaderSource(vertexShader, 1, &shaderSource, &shaderSourceLen)\r\nglCompileShader(vertexShader)\r\n\r\nfragmentShaderObject = glCreateShader(GL_FRAGMENT_SHADER);\r\nloadshader(\"shaderfile.frag\", &shaderSource, &shaderSourceLen)\r\nglShaderSource(vertexShader, 1, &shaderSource, &shaderSourceLen)\r\nglCompileShader(vertexShader)\r\n\r\nProgramObject = glCreateProgram();\r\nglAttachShader(ProgramObject, vertexShaderObject);\r\nglAttachShader(ProgramObject, fragmentShaderObject);\r\n\r\nglLinkProgram(ProgramObject);\r\n```\r\nSame on GL++\r\n\r\n```cpp\r\nglpp::shared_program_t pprog;\r\n\r\npprog = new glpp::program();\r\npprog->attach_shader(\r\n          glpp::open_shader_file(glpp::shader_type::VERTEX, \"shaderfile.vert\"));\r\npprog->attach_shader(\r\n          glpp::open_shader_file(glpp::shader_type::FRAGMENT, \"shaderfile.frag\"));\r\npprog->build();\r\npprog->use();\r\n```\r\n\r\nBuild\r\n=====\r\n\r\nGL++ uses [CMake](http://www.cmake.org/) build system. To continue you must ensure that you have the cmake installed on your system, and all the needed libraries.\r\n\r\nTo build the library you will need:\r\n* OpenGL headers/libraries - usually provided by your graphics driver\r\n* [FreeGLUT](http://freeglut.sourceforge.net)\r\n* [GLEW](http://glew.sourceforge.net/)\r\n\r\nTo build the examples you will need also:\r\n* [GLM](http://glm.g-truc.net/)\r\n* [FreeImage](http://freeimage.sourceforge.net/)\r\n* [Boost](http://www.boost.org)\r\n* [Assimp](http://assimp.sourceforge.net)\r\n\r\nIt is preferred to build project in a sub-folder than doing it directly in tree.\r\n\r\n```bash\r\nmkdir build\r\ncd build\r\ncmake ..\r\nmake\r\n```\r\n\r\nDocumentation\r\n=============\r\n\r\n[Doxygen](http://www.stack.nl/~dimitri/doxygen) is used for in-code documentation. You can build documentation files by simply running doxygen on the top folder where Doxyfile resides.\r\n\r\nRequest For Help\r\n================\r\n\r\nOpenGL has a big API, with a lot of history and this is reflected in many domains. Studing the API and trying to find the best C++ representation requires a lot of effort. Any person who can help on this procedure can be useful for this project. Even jannitoring is also welcome.\r\n\r\nPlease [contact us](https://github.com/sque/glpp) if you want to contribute.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}