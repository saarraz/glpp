/**
 * Copyright (c) 2012 Konstantinos Paliouras <squarious _ gmail _dot com>.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef GLPP_BUFFER_HPP_INCLUDED
#define GLPP_BUFFER_HPP_INCLUDED

#include "base.hpp"
#include <vector>

namespace glpp {

	//! A general object for unformatted linear memory allocated by the OpenGL context
	/**
	 * @remarks non-copyable, non-inheritable, RAII
	 * @ingroup gpu_buffer
	 * @todo: Buffer type is real type, and can/should be provided at compile time.
	 */
	struct buffer :
		public named_object<GLuint>,
		public noncopyable{

		//! Construct an empty buffer object
		/**
		 * http://www.opengl.org/sdk/docs/man4/xhtml/glGenBuffers.xml
		 * @param type Is the target that this buffer will be used for.
		 */
		buffer(buffer_type type);

		//! Destroy and release resources of buffer
		/**
		 * http://www.opengl.org/sdk/docs/man4/xhtml/glDeleteBuffers.xml
		 */
		~buffer();

		//! Get the defined target type that this buffer will be binded at.
		/**
		 * @see bind()
		 */
		inline buffer_type type() const {
			return m_buf_type;
		}

		//! Bind this buffer to its defined target type
		/**
		 * @see buffer(buffer_type), type()
		 * http://www.opengl.org/sdk/docs/man4/xhtml/glBindBuffer.xml
		 */
		inline void bind() const {
			::glBindBuffer( GLPP_CAST_TO_SCALAR(GLenum, type()), object_name());
		}

		//! Bind base at specific index of arrayed targets (valid for some types)
		/**
		 * http://www.opengl.org/sdk/docs/man4/xhtml/glBindBufferBase.xml
		 */
		void bind_to_point(GLuint point) const {
			::glBindBufferBase( GLPP_CAST_TO_SCALAR(GLenum, type()), point, object_name());
		}

		//! Bind a range to specific index of arrayed targets (valid for some types)
		/**
		 * http://www.opengl.org/sdk/docs/man4/xhtml/glBindBufferRange.xml
		 */
		void bind_to_point(GLuint point, size_t offset, size_t size) const {
			::glBindBufferRange( GLPP_CAST_TO_SCALAR(GLenum, type()), point, object_name(), offset, size);
		}

		//! The size of this buffer as defined by define_data()
		/**
		 * @ref exclusive_glpp_api define_data()
		 */
		inline size_t size() const {
			return m_size;
		}

		//! Create and initializes a buffer object's data store
		/**
		 * http://www.opengl.org/sdk/docs/man4/xhtml/glBufferData.xml
		 */
		void define_data(size_t size, const void * pdata, buffer_usage_pattern usage);

		//! Create and initializes a buffer object's data store
		/**
		 * http://www.opengl.org/sdk/docs/man4/xhtml/glBufferSubData.xml
		 */
		void update_subdata(size_t offset, size_t size, const void * pdata);

		//! Get a subset of a buffer object's data store
		/**
		 * @remarks You are adviced to prefer mapping instead of this technique.
		 * http://www.opengl.org/sdk/docs/man4/xhtml/glGetBufferSubData.xml
		 */
		std::vector<uint8_t> get_data(size_t offset, size_t size);

		//! Map buffer's storage to host memory address
		/**
		 * http://www.opengl.org/sdk/docs/man4/xhtml/glMapBuffer.xml
		 * @see unmap_data(), map_data_range()
		 */
		void * map_data(buffer_access_mode access);

		//! Unmap any previously mapped range.
		/**
		 * @remarks A mapped data store must be unmapped with glUnmapBuffer before
		 * its buffer object is used. Otherwise an error will be generated by any
		 * GL command that attempts to dereference the buffer object's data store.
		 *
		 * http://www.opengl.org/sdk/docs/man4/xhtml/glMapBuffer.xml
		 * @see map_data_range(), map_data()
		 */
		bool unmap_data();

		//! Map a range of buffer's storaget to host memory address
		/**
		 * http://www.opengl.org/sdk/docs/man4/xhtml/glMapBufferRange.xml
		 */
		void * map_data_range(size_t offset, size_t size, map_access_bit access);

		//! Indicate modifications to a range of a mapped buffer
		/**
		 * http://www.opengl.org/sdk/docs/man4/xhtml/glFlushMappedBufferRange.xml
		 */
		void flush_mapped_range(size_t offset, size_t size);

	protected:

		//! Buffer target type
		buffer_type m_buf_type;

		//! Size of this buffer storage
		size_t m_size;
	};
}

#endif
